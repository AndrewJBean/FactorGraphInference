#include "DiscreteFactorGraph.h"
#include <stdio.h>
#include <cmath>

#ifndef NULL
#define NULL 0
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////



// DONE
int FactorGraph::ReadGraph()
{
    int NumVars;
    // how many variables?
    cin >> NumVars;
    variables.resize(NumVars);
    // get the cardinality of each variable
    for(int i=0;i<NumVars;i++)
        cin >> variables[i].cardinality;

    int NumFns;
    // how many functions?
    cin >> NumFns;
    functions.resize(NumFns);
    // get the function properties
    for(int i=0;i<NumFns;i++)
    {
        int Degree;
        // first get the degree, number of connected variables
        cin >> Degree;
        functions[i].vars.resize(Degree);
        int ValuesSize = 1;
        for(int j=0;j<Degree;j++)
        {
            int Var;
            // retrieve the index of the connected variables
            cin >> Var;
            // indicate the function is connected to that variable
            functions[i].vars[j] = Var;
            // indicate the variable is connected to that function
            variables[Var].fns.push_back(i);
            // accumulate the number of function values (product of cardinalities)
            ValuesSize = ValuesSize * variables[Var].cardinality;
        }
        functions[i].ValuesSize = ValuesSize ;
        // get the index to the function values
        cin >> functions[i].values;
    }

    // how many function value vectors?
    int NumValues;
    cin >> NumValues;
    values.resize(NumValues);
    for(int i=0;i<NumValues;i++)
    {
        // how long is the set of values?
        int ValuesSize;
        cin >> ValuesSize;
        values[i].resize(ValuesSize);
        // get all the values
        for(int j=0;j<ValuesSize;j++)
        {
            cin >> values[i][j];
        }
    }
    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////


// DONE
int FactorGraph::WriteGraph()
{
    // how many variables?
    cout << variables.size() << endl;
    // get the cardinality of each variable
    for(int i=0;i<variables.size();i++)
        cout << variables[i].cardinality << ' ';
    cout << endl << endl;

    // how many functions?
    cout << functions.size() << endl << endl;
    // put the function properties
    for(int i=0;i<functions.size();i++)
    {
        // first put the degree, number of connected variables
        cout << functions[i].vars.size() << endl;
        for(int j=0;j<functions[i].vars.size();j++)
        {
            // put the index of the connected variables
            cout << functions[i].vars[j] << ' ';
        }
        cout << endl;
        // which values list
        cout << functions[i].values;
    }

    // how many function value vectors?
    cout << values.size();
    for(int i=0;i<values.size();i++)
    {
        // how long is the set of values?
        cout << values[i].size();
        // write all the values
        for(int j=0;j<values[i].size();j++)
        {
            cout << values[i][j];
        }
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

int FactorGraph::MyGet(int & value)
{
    int NumRead = fread(&value, sizeof(int), 1 , stdin);
    return ( NumRead != 1 );
}
int FactorGraph::MyGet(FloatType & value)
{
    int NumRead = fread(&value , sizeof(FloatType) , 1 , stdin);
    return ( NumRead != 1 );
}
void FactorGraph::MyPut(int value)
{
    fwrite(&(value), sizeof(value), 1, stdout);
}
void FactorGraph::MyPut(FloatType value)
{
    fwrite(&(value), sizeof(value), 1, stdout);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////


//
int FactorGraph::ReadGraphBin()
{
    int NumVars;
    // how many variables?
    if( MyGet(NumVars) ) return -1;
    variables.resize(NumVars);
    // get the cardinality of each variable
    for(int i=0;i<NumVars;i++)
    {
        if( MyGet(variables[i].cardinality) ) return -1;
    }

    int NumFns;
    // how many functions?
    if( MyGet(NumFns) ) return -1;
    functions.resize(NumFns);
    // get the function properties
    for(int i=0;i<NumFns;i++)
    {
        int Degree;
        // first get the degree, number of connected variables
        if( MyGet(Degree) ) return -1;
        functions[i].vars.resize(Degree);
        int ValuesSize = 1;
        // get the connected variables
        for(int j=0;j<Degree;j++)
        {
            int Var;
            // retrieve the index of the connected variables
            if( MyGet(Var) ) return -1;
            // indicate the function is connected to that variable
            functions[i].vars[j] = Var;
            // indicate the variable is connected to that function
            variables[Var].fns.push_back(i);
            // accumulate the number of function values (product of cardinalities)
            ValuesSize = ValuesSize * variables[Var].cardinality;
        }
        functions[i].ValuesSize = ValuesSize ;
        // get the index to the function values
        if( MyGet(functions[i].values) ) return -1;
    }

    // how many function value vectors?
    int NumValues;
    if( MyGet(NumValues) ) return -1;
    values.resize(NumValues);
    for(int i=0;i<NumValues;i++)
    {
        // how long is the set of values?
        int ValuesSize;
        if( MyGet(ValuesSize) ) return -1;
        values[i].resize(ValuesSize);
        // get all the values
        for(int j=0;j<ValuesSize;j++)
        {
            if( MyGet(values[i][j]) ) return -1;
        }
    }
    return 0;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
int FactorGraph::MyGet(int & value,ifstream & file)
{
    file.read((char*)&value,sizeof(int));
    return ( !file );
}
int FactorGraph::MyGet(FloatType & value,ifstream & file)
{
    file.read((char*)&value,sizeof(FloatType));
    return ( !file );
}
void FactorGraph::MyPut(int value,ofstream & file)
{
    file.write((char*)&(value), sizeof(value));
}
void FactorGraph::MyPut(FloatType value,ofstream & file)
{
    file.write((char*)&(value), sizeof(value));
}
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
int FactorGraph::ReadGraphBin(string const & FileName)
{
    ifstream file (FileName.c_str(), std::ifstream::binary);
    file.seekg(0);

    int NumVars;
    // how many variables?
    if( MyGet(NumVars,file) ) return -1;
    variables.resize(NumVars);
    // get the cardinality of each variable
    for(int i=0;i<NumVars;i++)
    {
        if( MyGet(variables[i].cardinality,file) ) return -1;
    }

    int NumFns;
    // how many functions?
    if( MyGet(NumFns,file) ) return -1;
    functions.resize(NumFns);
    // get the function properties
    for(int i=0;i<NumFns;i++)
    {
        int Degree;
        // first get the degree, number of connected variables
        if( MyGet(Degree,file) ) return -1;
        functions[i].vars.resize(Degree);
        int ValuesSize = 1;
        // get the connected variables
        for(int j=0;j<Degree;j++)
        {
            int Var;
            // retrieve the index of the connected variables
            if( MyGet(Var,file) ) return -1;
            // indicate the function is connected to that variable
            functions[i].vars[j] = Var;
            // indicate the variable is connected to that function
            variables[Var].fns.push_back(i);
            // accumulate the number of function values (product of cardinalities)
            ValuesSize = ValuesSize * variables[Var].cardinality;
        }
        functions[i].ValuesSize = ValuesSize ;
        // get the index to the function values
        if( MyGet(functions[i].values,file) ) return -1;
    }

    // how many function value vectors?
    int NumValues;
    if( MyGet(NumValues,file) ) return -1;
    values.resize(NumValues);
    for(int i=0;i<NumValues;i++)
    {
        // how long is the set of values?
        int ValuesSize;
        if( MyGet(ValuesSize,file) ) return -1;
        values[i].resize(ValuesSize);
        // get all the values
        for(int j=0;j<ValuesSize;j++)
        {
            if( MyGet(values[i][j],file) ) return -1;
        }
    }
    file.close();
    return 0;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
int FactorGraph::ReadGraphBin(ifstream & file)
{
    int NumVars;
    // how many variables?
    if( MyGet(NumVars,file) ) return -1;
    variables.resize(NumVars);
    // get the cardinality of each variable
    for(int i=0;i<NumVars;i++)
    {
        if( MyGet(variables[i].cardinality,file) ) return -1;
    }

    int NumFns;
    // how many functions?
    if( MyGet(NumFns,file) ) return -1;
    functions.resize(NumFns);
    // get the function properties
    for(int i=0;i<NumFns;i++)
    {
        int Degree;
        // first get the degree, number of connected variables
        if( MyGet(Degree,file) ) return -1;
        functions[i].vars.resize(Degree);
        int ValuesSize = 1;
        // get the connected variables
        for(int j=0;j<Degree;j++)
        {
            int Var;
            // retrieve the index of the connected variables
            if( MyGet(Var,file) ) return -1;
            // indicate the function is connected to that variable
            functions[i].vars[j] = Var;
            // indicate the variable is connected to that function
            variables[Var].fns.push_back(i);
            // accumulate the number of function values (product of cardinalities)
            ValuesSize = ValuesSize * variables[Var].cardinality;
        }
        functions[i].ValuesSize = ValuesSize ;
        // get the index to the function values
        if( MyGet(functions[i].values,file) ) return -1;
    }

    // how many function value vectors?
    int NumValues;
    if( MyGet(NumValues,file) ) return -1;
    values.resize(NumValues);
    for(int i=0;i<NumValues;i++)
    {
        // how long is the set of values?
        int ValuesSize;
        if( MyGet(ValuesSize,file) ) return -1;
        values[i].resize(ValuesSize);
        // get all the values
        for(int j=0;j<ValuesSize;j++)
        {
            if( MyGet(values[i][j],file) ) return -1;
        }
    }
    return 0;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////


//
int FactorGraph::WriteGraphBin()
{
    // how many variables?
    MyPut((int)variables.size());
    // put the cardinality of each variable
    for(int i=0;i<variables.size();i++)
    {
        MyPut((int)variables[i].cardinality);
    }

    // how many functions?
    MyPut((int)functions.size());

    // put the function properties
    for(int i=0;i<functions.size();i++)
    {
        // first put the degree, number of connected variables
        MyPut((int)functions[i].vars.size());
        for(int j=0;j<functions[i].vars.size();j++)
        {
            // put the index of the connected variables
            MyPut((int)functions[i].vars[j]);
        }
        // which values list
        MyPut((int)functions[i].values);
    }

    // how many function value vectors?
    MyPut((int)values.size());
    for(int i=0;i<values.size();i++)
    {
        // how long is the set of values?
        MyPut((int)values[i].size());
        // write all the values
        for(int j=0;j<values[i].size();j++)
        {
            MyPut((FloatType)values[i][j]);
        }
    }

    return 0;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////



int FactorGraph::WriteGraphBin(string const & FileName)
{
    ofstream file (FileName.c_str(), std::ofstream::binary);
    file.seekp (0);

    // how many variables?
    MyPut((int)variables.size(),file);
    // put the cardinality of each variable
    for(int i=0;i<variables.size();i++)
    {
        MyPut((int)variables[i].cardinality,file);
    }

    // how many functions?
    MyPut((int)functions.size(),file);

    // put the function properties
    for(int i=0;i<functions.size();i++)
    {
        // first put the degree, number of connected variables
        MyPut((int)functions[i].vars.size(),file);
        for(int j=0;j<functions[i].vars.size();j++)
        {
            // put the index of the connected variables
            MyPut((int)functions[i].vars[j],file);
        }
        // which values list
        MyPut((int)functions[i].values,file);
    }

    // how many function value vectors?
    MyPut((int)values.size(),file);
    for(int i=0;i<values.size();i++)
    {
        // how long is the set of values?
        MyPut((int)values[i].size(),file);
        // write all the values
        for(int j=0;j<values[i].size();j++)
        {
            MyPut((FloatType)values[i][j],file);
        }
    }

    file.close();
    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
int FactorGraph::WriteGraphBin(ofstream & file)
{
    // how many variables?
    MyPut((int)variables.size(),file);
    // put the cardinality of each variable
    for(int i=0;i<variables.size();i++)
    {
        MyPut((int)variables[i].cardinality,file);
    }

    // how many functions?
    MyPut((int)functions.size(),file);

    // put the function properties
    for(int i=0;i<functions.size();i++)
    {
        // first put the degree, number of connected variables
        MyPut((int)functions[i].vars.size(),file);
        for(int j=0;j<functions[i].vars.size();j++)
        {
            // put the index of the connected variables
            MyPut((int)functions[i].vars[j],file);
        }
        // which values list
        MyPut((int)functions[i].values,file);
    }

    // how many function value vectors?
    MyPut((int)values.size(),file);
    for(int i=0;i<values.size();i++)
    {
        // how long is the set of values?
        MyPut((int)values[i].size(),file);
        // write all the values
        for(int j=0;j<values[i].size();j++)
        {
            MyPut((FloatType)values[i][j],file);
        }
    }
    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////




FloatType FactorGraph::LogValue(vector< int > const & Values)
{
    FloatType Total = 0.0;
    for(auto Fn:functions)
    {
        // find index into function kernel
        int Index = 0;
        for(int i=Fn.vars.size()-1;i>=0;i--)
        {
            Index *= variables[Fn.vars[i]].cardinality;
            Index += Values[Fn.vars[i]];
        }
        // add the log of the kernel value
        Total += log(values[Fn.values][Index]);
    }
    return Total;
}






